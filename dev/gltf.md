# glTF

- https://github.com/KhronosGroup/glTF

## Spec

https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html

- coordinate system
    - world up: y
    - front: z
    - right-handed
- entities
    - scene
    - node
    - skin
    - camera
    - mesh
    - accessor
    - bufferView
        - chunk of buffer
        - specified by offset and length
    - buffer
        - raw binary data
    - image
        - referred by a URI
        - may refer to a buffer view
    - texture
        - contains
            - sampler
            - image
        - texture coordinates
            - (0,0) top left
            - (1,0) top right
            - (0,1) bottom left
            - (1,1) bottom right
    - sampler
        - defines resampling method
            - e.g. LINEAR
    - animation
        - contains
            - sampler
            - channel
- transformation
    - order
        - T@R@S
        - (scale applied first)

### Material

https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#materials

```json
{
    "materials": [
        {
            "name": "gold",
            "pbrMetallicRoughness": {
                "baseColorFactor": [ 1.000, 0.766, 0.336, 1.0 ],
                "metallicFactor": 1.0,
                "roughnessFactor": 0.0
            }
        }
    ]
}
```

```json
{
    "materials": [
        {
            "pbrMetallicRoughness": {
                "baseColorTexture": {
                    "index": 0,
                    "texCoord": 1
                },
            }
        }
    ],
    "textures": [
        {
            "source": 0
        }
    ],
    "images": [
        {
            "uri": "base_color.png"
        }
    ]
}
```

(generated by chatgpt)

```python
import trimesh
from PIL import Image
from trimesh.visual.texture import SimpleMaterial, TextureVisuals


if __name__ == "__main__":
    plane = trimesh.creation.box(extents=(1, 1, 0.01))
    plane.vertices[:, 2] = 0.0

    # Set UVs: map (x, y) from (-0.5, 0.5) to (0, 1)
    min_xy = plane.vertices[:, :2].min(axis=0)
    max_xy = plane.vertices[:, :2].max(axis=0)
    uv = (plane.vertices[:, :2] - min_xy) / (max_xy - min_xy)

    # Load the image as a PIL.Image object
    img = Image.open("asphalt.jpg")

    # Set a texture image using SimpleMaterial with a PIL.Image
    material = SimpleMaterial(image=img)
    plane.visual = TextureVisuals(uv=uv, image=img, material=material)

    plane.export("plane_with_textures.glb", file_type="glb")
```

```python
from dataclasses import dataclass, field
from typing import List, Optional

import numpy as np
import pygltflib
import trimesh


@dataclass
class TextureInfo:
    uri: str
    tex_coord: Optional[int] = 0


@dataclass
class PbrMetallicRoughness:
    base_color_factor: Optional[List[float]] = field(default_factory=lambda: [1.0, 1.0, 1.0, 1.0])
    metallic_factor: Optional[float] = 1.0
    roughness_factor: Optional[float] = 1.0
    base_color_texture: Optional[TextureInfo] = None
    metallic_roughness_texture: Optional[TextureInfo] = None


@dataclass
class Material:
    pbr_metallic_roughness: Optional[PbrMetallicRoughness] = None
    normal_texture: Optional[TextureInfo] = None
    occlusion_texture: Optional[TextureInfo] = None
    emissive_factor: Optional[List[float]] = field(default_factory=lambda: [0.0, 0.0, 0.0])
    emissive_texture: Optional[TextureInfo] = None
    alpha_mode: Optional[str] = "OPAQUE"
    alpha_cutoff: Optional[float] = None
    double_sided: Optional[bool] = False
    name: Optional[str] = None


def trimesh_to_gltf_mesh(mesh: trimesh.Trimesh) -> pygltflib.GLTF2:
    """Convert a trimesh mesh into a GLTF2 object without textures/materials.

    The GLTF2 object is returned (not saved).
    """
    gltf = pygltflib.GLTF2(asset=pygltflib.Asset(version="2.0"))

    # Pack mesh data
    vertices = mesh.vertices.astype(np.float32).tobytes()
    uv = getattr(mesh.visual, "uv", None)
    texcoords = uv.astype(np.float32).tobytes() if uv is not None else None
    indices = mesh.faces.astype(np.uint32).tobytes()

    # Buffers
    buffer = pygltflib.Buffer(
        byteLength=len(vertices) + (len(texcoords) if texcoords else 0) + len(indices)
    )
    gltf.buffers.append(buffer)

    idx_buffer_view = 0
    idx_accessor = 0

    # Positions view & accessor
    pos_view = pygltflib.BufferView(buffer=0, byteOffset=0, byteLength=len(vertices))
    gltf.bufferViews.append(pos_view)
    gltf.accessors.append(
        pygltflib.Accessor(
            bufferView=idx_buffer_view, componentType=5126, count=len(mesh.vertices), type="VEC3"
        )
    )
    attrs = {"POSITION": idx_accessor}
    idx_buffer_view += 1
    idx_accessor += 1

    # Texcoords view & accessor (if present)
    if texcoords:
        tex_view = pygltflib.BufferView(
            buffer=0, byteOffset=len(vertices), byteLength=len(texcoords)
        )
        gltf.bufferViews.append(tex_view)
        gltf.accessors.append(
            pygltflib.Accessor(
                bufferView=idx_buffer_view, componentType=5126, count=len(uv), type="VEC2"
            )
        )
        attrs["TEXCOORD_0"] = idx_accessor
        idx_buffer_view += 1
        idx_accessor += 1

    # Indices view & accessor
    idx_view = pygltflib.BufferView(
        buffer=0,
        byteOffset=len(vertices) + (len(texcoords) if texcoords else 0),
        byteLength=len(indices),
    )
    gltf.bufferViews.append(idx_view)
    gltf.accessors.append(
        pygltflib.Accessor(
            bufferView=idx_buffer_view, componentType=5125, count=mesh.faces.size, type="SCALAR"
        )
    )
    indices_accessor = idx_accessor

    primitive = pygltflib.Primitive(attributes=attrs, indices=indices_accessor, material=None)
    gltf.meshes.append(pygltflib.Mesh(primitives=[primitive]))

    # Node + Scene
    gltf.nodes.append(pygltflib.Node(mesh=0))
    gltf.scenes.append(pygltflib.Scene(nodes=[0]))
    gltf.scene = 0

    # Embed raw buffer data
    combined = vertices
    if texcoords:
        combined += texcoords
    combined += indices
    gltf.set_binary_blob(combined)

    return gltf


def apply_material_to_gltf(gltf: pygltflib.GLTF2, material: Material) -> None:
    """Apply a user-defined Material object to a GLTF2 object."""

    def _add_texture(texinfo: TextureInfo):
        idx_image = len(gltf.images)
        gltf.images.append(pygltflib.Image(uri=texinfo.uri))
        gltf.samplers.append(pygltflib.Sampler())
        gltf.textures.append(pygltflib.Texture(sampler=len(gltf.samplers) - 1, source=idx_image))

    mat = pygltflib.Material()
    # PBR
    if material.pbr_metallic_roughness:
        mat.pbrMetallicRoughness = pygltflib.PbrMetallicRoughness()
        pmr = material.pbr_metallic_roughness
        mat.pbrMetallicRoughness.baseColorFactor = pmr.base_color_factor
        mat.pbrMetallicRoughness.metallicFactor = pmr.metallic_factor
        mat.pbrMetallicRoughness.roughnessFactor = pmr.roughness_factor
        if pmr.base_color_texture:
            _add_texture(pmr.base_color_texture)
            mat.pbrMetallicRoughness.baseColorTexture = {"index": len(gltf.textures) - 1}
        if pmr.metallic_roughness_texture:
            _add_texture(pmr.metallic_roughness_texture)
            mat.pbrMetallicRoughness.metallicRoughnessTexture = {"index": len(gltf.textures) - 1}
    # Normal
    if material.normal_texture:
        _add_texture(material.normal_texture)
        mat.normalTexture = {"index": len(gltf.textures) - 1}
    # Occlusion
    if material.occlusion_texture:
        _add_texture(material.occlusion_texture)
        mat.occlusionTexture = {"index": len(gltf.textures) - 1}
    # Emissive
    if material.emissive_texture:
        _add_texture(material.emissive_texture)
        mat.emissiveTexture = {"index": len(gltf.textures) - 1}
    mat.emissiveFactor = material.emissive_factor
    mat.alphaMode = material.alpha_mode
    mat.alphaCutoff = material.alpha_cutoff
    mat.doubleSided = material.double_sided
    mat.name = material.name

    gltf.materials.append(mat)
    if gltf.meshes and gltf.meshes[0].primitives:
        gltf.meshes[0].primitives[0].material = len(gltf.materials) - 1


if __name__ == "__main__":
    plane = trimesh.creation.box(extents=(1, 1, 0.01))
    plane.vertices[:, 2] = 0.0

    # Set UVs: map (x, y) from (-0.5, 0.5) to (0, 1)
    min_xy = plane.vertices[:, :2].min(axis=0)
    max_xy = plane.vertices[:, :2].max(axis=0)
    uv = (plane.vertices[:, :2] - min_xy) / (max_xy - min_xy)
    plane.visual.uv = uv

    gltf = trimesh_to_gltf_mesh(plane)
    apply_material_to_gltf(
        gltf,
        Material(
            pbr_metallic_roughness=PbrMetallicRoughness(
                base_color_texture=TextureInfo(uri="asphalt.jpg")
            )
        ),
    )
    gltf.save("plane_with_textures.glb")


```
